\documentclass[sigplan,review,11pt,nonacm,natbib=false]{acmart}
\settopmatter{printfolios=false,printccs=false,printacmref=false}
\usepackage[maxnames=1,minnames=1,maxbibnames=100,natbib=true,citestyle=authoryear,bibstyle=authoryear,doi=false,url=false,isbn=false,isbn=false,backend=biber]{biblatex}
\usepackage{debate}
\usepackage[T2A,T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian,english]{babel}
\renewcommand\ttdefault{cmtt}
\usepackage{csquotes}
\usepackage{ffcode}
\usepackage{CJKutf8}
\usepackage{paralist}
\usepackage{cancel} % to enable \cancel command
\usepackage{anyfontsize} % To get rid of font not found warnings
\usepackage{tabularx} % for special tables
\usepackage{amsmath}
\usepackage{to-be-determined}
\usepackage{href-ul}
\usepackage{amsthm}
\usepackage{cleveref}
\usepackage{tcolorbox} % for algorithm
\tcbuselibrary{skins}
\usepackage{fdsymbol} % for \mathbb
\usepackage{algpseudocode} % for algorithms
\usepackage{multicol} % for two cols in BNF
\usepackage{pgffor} % to enable \foreach
\usepackage{stmaryrd}
\usepackage{mathtools}
\newtheoremstyle{theorems}
{} % Space above
{} % Space below
{} % Theorem body font % (default is "\upshape")
{} % Indent amount
{\scshape} % Theorem head font % (default is \mdseries)
{.} % Punctuation after theorem head % default: no punctuation
{ } % Space after theorem head
{} % Theorem head spec
\theoremstyle{theorems}
\newtheorem{eodefinition}{Definition}
\newtheorem{eotheorem}{Theorem}


\addbibresource{refs.bib}

\newcommand\br{\\[-4pt]}
\newcounter{rule}
\renewcommand\therule{R\arabic{rule}}
\newcommand\rr{\smalltriangleright{}}
\newcommand\rrule[1]{{\scshape\sffamily\ref{rule:#1}}}
\newcommand{\jrule}[1]{%
    \refstepcounter{rule}\label{rule:#1}%
    \text{\textbf{\rrule{#1}}}}

\newcommand\sgm[1]{$\sigma_#1$}
\newcommand\dlt[1]{$\delta_#1$}
\newcommand\m[1]{$\mu_#1$}

\title{Elimination Of Jump Objects}
\author{author}

\begin{document}

    \maketitle

    \section{Introduction}
    The problem of eliminating Jump-like statements is known for both computer science and software engineering communities for a few decades and formulated by several scientists, some of which have suggested solutions for this problem.

    The presence of jump statements in the source code makes it impossible to use the functional method of analysis.
    Other program analysis methods, including those based on symbolic execution techniques, will also benefit from the removal of jump statements, which are well-known obstacles to the precision of analysis, as explained by \citet{baldoni2018survey}.

    There are an "object-flow" languages where the execution flow is controlled by object composition.
    An example of such a language is EO, which is based on $\varphi$-calculus introduced by \citet{bugayenko2021eolang} and formalized by \citet{kudasov2021}.
    This is a strictly object-oriented programming language in which any action is described by creating a new object, or decorating an existing one.

    We are trying to answer the following research question: "Is it possible for any program, written in 'object-flow' language like EO and containing GOTO objects, to find a semantically equivalent program, but without GOTO objects?"

    \section{Related work}
    The problem was firstly formulated by \citet{dijkstra1968letters}: he affirmed that the use of GOTO has disastrous effect and proposed to remove it from all programming languages.
    Even though a few years later \citet{knuth1974structured} showed a manner for structuring programs with the GOTO statement and argued that it could be a powerful tool if it is well used, researchers got interested in finding a way for restructuring programs and eliminating GOTO statements \citep{arsac1977construction}.

    To solve the problem of eliminating Jump statements in other programming languages, the following works were published:
    \Citet{williams1985restructuring} created a tool for restructuring Pascal code;
    \Citet{jonsson1989next} was one of the first who made a summary of so called GOTO-patches, which are design techniques for eliminating GOTO statements;
    \Citet{erosa1994taming} suggested an algorithm for automatic elimination of GOTO statements in~C;
    \Citet{zegour1994new} explained how GOTO elimination may work in any language, as long as it has jump statements and control structures;
    \Citet{morris1997goto} suggested to use regular expressions for replacing GOTO with IF-THEN-ELSE constructs;
    \Citet{ramshaw1988eliminating} proposed an algorithm for Pascal programs;
    \Citet{ganapathi2008shim} introduced optimization method for SHIM IR;
    \Citet{ceccato2008goto} suggested how to eliminate GOTO during migration of legacy code to Java.

    However, to our knowledge, there is still no method available, which enables automatic elimination of jump objects in programs written in such an object-flow languages.


    \section{Definitions and designations}
    \begin{eodefinition}
        \emph{Dataization} in $\varphi$-calculus is a process of retrieving data from an object.
        The dataization of an object at the highest level of composition leads to the execution of a program.
    \end{eodefinition}
    \begin{eodefinition} \emph{Nesting} of the current object determines the number of objects that encapsulate current object via abstraction, application, or decoration directly or through other objects.

    For example, here object $x$ has 3-rd level of nesting:
    \begin{ffcode}
        o1
        o2
        ...
        o3
        o4
        x
    \end{ffcode}
    \end{eodefinition}
    \begin{eodefinition}
        \emph{Forwarding goto} denotes an object \ff{goto}, which encapsulate object \ff{forward} directly or through other objects:
        \begin{ffcode}
            goto
            [o1]
            ...
            |$\leadsto$|o1.forward o2
            ...
        \end{ffcode}
    \end{eodefinition}
    \begin{eodefinition}
        \emph{Backwarding goto} denotes an object \ff{goto}, which encapsulate object \ff{backward} directly or through other objects:
        \begin{ffcode}
            goto
            [o1]
            ...
            |$\leadsto$|o1.backward
            ...
        \end{ffcode}
    \end{eodefinition}
    \emph{Designations:}
    \begin{itemize}
        \item "$>$" is used to name attributes of an object, where on the left side of ">" is attribute itself and its name on the right side,
        \item "$[]$" is used for the specification of parameters of abstract objects,
        \item "$@$" is used to denote the object being decorated,
        \item "$\mapsto$" is used to denote an object, where free attributes stay in the parentheses on the left side and pairs, which represent bound attributes, stay on the right side, in double-square brackets,
        \item "$\leadsto$" denotes an arbitrary \emph{nesting} of an object, i.e. it can be encapsulated by an arbitrary number of objects.
    \end{itemize}


    \section{Sample}
    Let's consider the following example of code in EO, which uses GOTO object:

    \begin{ffcode}
        memory 0 > x
        [] > func
        goto > @
        [g]
        seq > @
        x.write (x.plus 1)
        if.
        x.lt 10
        g.backward
        QQ.io.stdout "X >= 10!\n"
        g.forward x
    \end{ffcode}

    \debate[Yegor]{Here I suggest we briefly explain the syntax of EO, since the language is not widely known. The reader will not understand what this code means and won't be able to digest it. Moreover, I would even suggest to also show a similar code in C++ language, so that the reader understand it better.

    ----------------Done}

    In this code snippet declares an \emph{atom}-object \ff{goto} with attribute \ff{g};
    mutable object \ff{memory}, which allows to reinitialize the bound object \ff{x} via \ff{.write} attribute;
    object \ff{eq}, which checks the equality of the objects passed to it;
    object \ff{if}, implementing behavior of branching;
    object \ff{seq}, which contains bound attributes as objects, which will be sequentially dataized;
    objects \ff{backward} and \ff{forward}, which are implementing behaviour of jumps: first of them starts dataization of object \ff{g} again, while the second one dataizes an object, passed as an attribute, and terminates dataization of object \ff{g}.

    Similar code snippet on C++ will be represented as:
    \begin{ffcode}
        int x = 0;
        int func() {
            l1:
            x = x + 1;
            if (x < 10)
            goto l1;
            else
            cout << "X >= 10!\n";
            return x;
        }
    \end{ffcode}

    We provide four independent transformations that replace \ff{goto} objects with a semantically equivalent analogue. After transformations, this example will appear as:
    \begin{ffcode}
        memory 0 > fl_1
        memory -1 > fl_2
        memory 0 > x
        [] > func
        seq > @
        fl_1.write 0
        fl_2.write -1
        while. > rem!
        or.
        fl_1.eq 0
        fl_2.eq -1
        [i]
        seq > @
        fl_1.write 1
        fl_2.write 0
        x.write (x.plus 1)
        if.
        x.lt 10
        fl_1.write 0
        QQ.io.stdout "X >= 10!\n"
        if.
        fl_1.eq 1
        fl_2.write 1
        TRUE
        if.
        fl_2.eq 1
        x
        rem
    \end{ffcode}

    Here, \ff{while} is an object, implementing behavior of loops: its first bound attribute implements condition of loop dataization and second one implies "body" of loop.

    On C++, the code snippet above after transformation will presented as:
    \begin{ffcode}
        int fl_1 = 0;
        int fl_2 = 0;
        int x = 0;
        int func() {
            fl_1 = 0;
            fl_2 = -1;
            do {
                fl_1 = 1;
                fl_2 = 0;
                x = x + 1;
                if (x < 10)
                fl_1 = 0;
                else
                cout << "X >= 10!\n";
                if (fl_1 == 1)
                fl_2 = 1;
            } while (fl_1 == 0 || fl_2 == -1);
            if (fl_2 == 1)
            return x;
        }
    \end{ffcode}



    Thus, the main purpose of our research is:
    \begin{enumerate}
        \item To formulate inference rules for the transformations that we propose,
        \item proof that these 4 transformations are necessary and sufficient to solve the problem under consideration,
        \item suggest a program tool, which
        enables automatic elimination of jump objects in programs written in EO.
    \end{enumerate}



    \section{Method}
    In this article, we will describe an algorithm that will convert an EO program in such a way that the output returns a semantically equivalent program, but without using the GOTO object.

    Some objects in EO may need to be platform specific and can’t be composed from other existing objects — they are called \emph{atoms}.
    All jump statements are implemented as a
    single \emph{atom}-object \ff{goto}.
    The implementation of \ff{goto} in EO implies two types of jumps - forward jump and backward jump.
    It is required to cover all possible cases for both of them.

%%The proposed algorithm is a series of transformations that are performed depending on the type of "jump".
    In total, we describe 4 types of transformations:
    \begin{inparaenum}[1)]
    \item \emph{Simple goto} (further \emph{SG}),
    \item \emph{Goto forward/backward} (further \emph{GF}/\emph{GB}) and
    \item \emph{Terminating the while object} (further \emph{TW}).

    Transformations are independent and not sequential, and each one is executed in its own particular case.
    For example, \emph{SG} is only a "preparation" for the actual replacement of the jump by a semantically equivalent analog and is executed if there is no condition before the jump itself.
    \emph{GF}/\emph{GB} are the main transformations, as they contain the jump replacement itself and cover most possible cases of using forward and backward jumps.
    \emph{TW} is an "addition" for \emph{GF} and \emph{GB} transformations, since the behavior of the \ff{while} object in EO is different from all other objects and dataization of jump inside the loop requires separate consideration.
    \end{inparaenum}

%%Thus, the algorithm itself consists of the following steps:
%%\begin{inparaenum}[1)]
%%\item Apply \emph{SF}/\emph{SB} transformation if necessary,
%%\item Find all occurrences of forward/backward jump's calls,
%%\item Apply \emph{GF}/\emph{GB} transformations to all of them,
%%\item If there is a \emph{while.} object that wraps the jump call, apply the \emph{WF}/\emph{WB} transformation.
%%\end{inparaenum}

    The combination of all 4 transformations implies a complete algorithm for getting rid of the GOTO object, as they cover all possible cases of using GOTO and forward/backward jumps in the language.

    Since we consider a solution to the problem in strictly object-oriented programming languages, which means that the whole program is a set of objects where some objects can encapsulate others.
    It should be noted that each object in the program has its own level of \emph{nesting} relative to other objects.



    \debate[Yegor]{If you give a definition, make sure it's followed by example. Now it's not really clear what it means.

    -----------------Done}

    We will also consider our transformations in the form of $\varphi$-calculus, on which EO is based.
    The proposed $\varphi$-calculus represents an object model through data and objects, while operations with them are possible through abstraction, application and decoration.
    The calculus introduces a formal apparatus for manipulations with objects.




    \subsection{Simple goto} \label{SG}
    As mentioned above, this transformation is a "preparation" for \emph{GF}/\emph{GB} which are make the replacement of object \ff{goto} itself.
    Since \emph{GF} and \emph{GB} only consider the use of the \ff{forward}/\ff{backward} objects when they are directly encapsulated in the \ff{if} object(\cref{GF}/\cref{GB}), it is required to add an additional \ff{if} when it is absent before the jump.
    Thus, the transformation under consideration adds an additional fictitious condition $\emph{if (true)}$ if it necessary.

    Let's consider the case where the \ff{forward} is not directly encapsulated in the \ff{if} object:
    \begin{ffcode}
        goto
        [g]
        |$\leadsto$|x|$\label{ln:sf0}$|
        |$\alpha_1$|
        ...
        |$\alpha_n$|
        g.forward y
        |$\alpha_{n+1}$|
        ...
        |$\alpha_{m}$||$\label{ln:sf1}$|
    \end{ffcode}
    Here, $\alpha_{i}$, $x$ and $y$ defines any object in the language, excluding \ff{if}.

    Applying the transformation, the example above maps to:
    \begin{ffcode}
        goto
        [g]
        |$\leadsto$|x|$\label{ln:tsf0}$|
        |$\alpha_1$|
        ...
        |$\alpha_n$|
        if.
        TRUE
        g.forward y
        TRUE
        |$\alpha_{n+1}$|
        ...
        |$\alpha_{m}$||$\label{ln:tsf1}$|
    \end{ffcode}

    Describing transformation in terms of $\varphi$-calculus, code at lines ~\ref{ln:sf0}---\ref{ln:sf1} will be represented as:
    \begin{equation}
        \begin{split}
            & x(\alpha_1,\,\ldots\,,\,\alpha_n, \br
            & \quad \emph{g}.\ff{forward}( y ), \br
            & \quad \alpha_{n+1},\,\ldots\,,\,\alpha_m) \\
        \end{split}
    \end{equation}
    and code at lines ~\ref{ln:tsf0}---\ref{ln:tsf1} as:
    \begin{equation}
        \begin{split}
            & x(\alpha_1,\,\ldots\,,\,\alpha_n, \br
            & \quad \ff{TRUE}.\ff{if}(\emph{g}.\ff{forward}( y )), \br
            & \quad \alpha_{n+1},\,\ldots\,,\,\alpha_m) \\
        \end{split}
    \end{equation}

    \begin{eotheorem}
        Any object is semantically equivalent to the same object encapsulated in \ff{TRUE}.\ff{if}:
        \begin{equation*}
            \forall x (x \equiv \ff{TRUE}.\ff{if}(x)).
        \end{equation*}
    \end{eotheorem}

    \begin{proof}
        By definition of the language, if there is any object \emph{Z}, then the following equivalence follows:
        \begin{equation}
            Z \equiv if(true,\,Z,\,true),
        \end{equation}
        where first argument in \emph{if} is condition itself, second argument dataizes when condition is \emph{true} and third argument dataizes when condition is \emph{false}.
    \end{proof}

    \begin{equation*}
        \dfrac
        {\begin{split}
             & x(\alpha_1,\,\ldots\,,\,\alpha_n, \br
             & \quad \emph{g}.\ff{forward}( y ), \br
             & \quad \alpha_{n+1},\,\ldots\,,\,\alpha_m) \\
        \end{split}}
        {\begin{split}
             & x(\alpha_1,\,\ldots\,,\,\alpha_n, \br
             & \quad \ff{TRUE}.\ff{if}(\emph{g}.\ff{forward}( y )), \br
             & \quad \alpha_{n+1},\,\ldots\,,\,\alpha_m) \\
        \end{split}}
        \jrule{1}
    \end{equation*}

%%Note that in this example, \ff{forward} is simply an attribute of the abstract object \emph{g} and is dataized as soon as the queue reaches it.
    In such cases where there is an "unconditional" jump, first of all we transform it into "conditional" jump by encapsulating it in additional object \ff{if}---\emph{if (true)}.
    This will not violate the program logic, since added condition will always be \emph{TRUE} and "THEN" brunch of if-statement with object \ff{forward} will always be dataized.

    The same logic applies with the \ff{backward} object.





    \subsection{Goto forward} \label{GF}
    In this section, we discuss the transformation by replacing \emph{forwarding goto} with a semantic equivalent.
    Based on the concept of transformation, only cases in which \ff{forward} is directly encapsulated in the object \ff{if} are considered.

    The essence of the transformation is that we create an additional $flag$ object which will assign as "0" or "1" and will show whether the jump condition has been met.
    Instead of dataization \ff{forward}, we will dataize the object passed to it as an argument and reinitialize the $flag$ object.
    Moreover, it is necessary to protect from dataization all objects following the \ff{if} object containing the jump, and with \emph{nesting} not less than that of the goto object itself, since they should not be dataized when the jump condition is met.
    This requires encapsulating each such object with an additional object \ff{if} to check the equality $flag$ to an object \ff{TRUE} - i.e. whether the jump condition has been met before or not.

    Let's consider the following example:
    \begin{ffcode}
        goto
        [g]
        |$\leadsto$|x|$\label{ln:of0}$|
        |$\alpha_1$|
        ...
        |$\alpha_n$|
        if.
        k
        g.forward y
        |$\alpha_{n+1}$|
        |$\alpha_{n+2}$|
        ...
        |$\alpha_{m}$|
        |$\alpha_{m+1}$||$\label{ln:of1}$|
        ...
    \end{ffcode}
    Here, $\alpha_i$, $x$ and $y$ defines any object in the language, $k$ defines an object, which when dataized equals to a data object \ff{TRUE}.

    \debate[Yegor]{We don't have 'values' in EO. We only have objects. Moreover, we don't 'return' anything. The result of dataization may be equal to a data object 'TRUE'.}

    Applying the transformation, the example above maps
    to:
    \begin{ffcode}
        memory 0 > flag
        goto
        [g]
        |$\leadsto$|x|$\label{ln:tof0}$|
        |$\alpha_1$|
        ...
        |$\alpha_n$|
        if.
        k
        seq
        y
        flag.write 1
        |$\alpha_{n+1}$|
        if.
        eq. (flag 0)
        |$\alpha_{n+2}$|
        TRUE
        ...
        if.
        eq. (flag 0)
        |$\alpha_{m}$|
        TRUE
        if.
        eq. (flag 0)
        |$\alpha_{m+1}$|
        TRUE|$\label{ln:tof1}$|
        ...
    \end{ffcode}

    In terms of $\varphi$-calculus lines ~\ref{ln:of0}--\ref{ln:of1} appears as:
    \begin{equation}
        \begin{split}
            & x (\alpha_1,\,\ldots\,,\,\alpha_n, \br
            & \quad k.\ff{if}(\,\emph{g}.\ff{forward}( y ),\,\alpha_{n+1}),\br
            & \quad \alpha_{n+2},\,\ldots\,,\,\alpha_m), \\
            & \alpha_{m+1} \\
        \end{split}
    \end{equation}
    whereas the lines ~\ref{ln:tof0}--\ref{ln:tof1} will be represented as:
    \begin{equation}
        \begin{split}
            & x (\alpha_1,\,\ldots\,,\,\alpha_n, \br
            & \quad k.\ff{if}(\ff{seq}(y,\,flag.\ff{write}(1)),\,\alpha_{n+1}),\br
            & \quad flag.\ff{eq}(0).\ff{if}(\alpha_{n+2}),\,\ldots\,,\br
            & \quad flag.\ff{eq}(0).\ff{if}(\alpha_m)), \\
            & flag.\ff{eq}(0).\ff{if}(\alpha_{m+1}) \\
        \end{split}
    \end{equation}

    \begin{eotheorem}
        \emph{Forwarding goto} maps to semantically equivalent analog without \ff{forward} objects:
        \begin{equation*}
            \begin{split}
                & \ff{goto}(\llbracket g\,\mapsto\,\varnothing,\,\varphi\,\leadsto\,x(\ldots,\,\leadsto g.\ff{forward}(y),\,\ldots)\rrbracket) \\
                & \downarrow \\
                & \ff{goto}(\llbracket g\,\mapsto\,\varnothing,\,\varphi\,\leadsto\,x(\ldots,\,\leadsto y,\,\ldots)\rrbracket) \\
            \end{split}
        \end{equation*}
    \end{eotheorem}

    \begin{proof}
        Let's introduce the following recursive function:
        \begin{equation}
            \begin{split}
            (\forall x\,\in\,\emph{attr}(\emph{g})):\,\phi(x)\,&\rightarrow\,(\mu(x),\,\phi(x'\,\neq\,x)) \\
            &\rightarrow\,(\mu(x),\,(\mu(x'),\,\phi(x''))) \\
            &\ldots
            \end{split}
        \end{equation}
        where \emph{attr}(\ldots) denotes all attributes of an object,
        \begin{equation}
            \begin{split}
                & \mu(x)\,\rightarrow flag.\ff{eq}(0).\ff{if}(x) .\\
            \end{split}
        \end{equation}
        Then the Ex. \ref{GFex1} maps to Ex. \ref{GFex2} according to the logic of dataization of \ff{goto} object with an attribute \ff{forward}.
        \debate[Yegor]{The discussion flow is broken here. Why this expression is here? What it belongs to? You can't start a sentence with an expression.}
        \begin{equation}\label{GFex1}
        \begin{split}
            & \ff{goto}(\llbracket\,\emph{g}\,\mapsto\,\varnothing,\br
            & \quad \quad \varphi\,\leadsto\,x(\ldots,\br
            & \quad \quad \quad k.\ff{if}(\emph{g}.\ff{forward}(y),\,z),\br
            & \quad \quad \quad w,\,\ldots)\rrbracket) \\
        \end{split}
        \end{equation}
        Here, $x$, $w$, $y$ and $z$ defines any object in the language, $k$ defines an object, which when dataized equals to a data object \ff{TRUE}.
        \begin{equation}\label{GFex2}
        \begin{split}
            & \ff{goto}(\llbracket\,\emph{g}\,\mapsto\,\varnothing,\br
            & \quad \quad \varphi\,\leadsto\,x(\ldots,\br
            & \quad \quad \quad k.\ff{if}(\ff{seq}(y,\,flag.\ff{write}(1)),\,z),\br
            & \quad \quad \quad \phi(w))\rrbracket) \\
        \end{split}
        \end{equation}
        Indeed, depending on the jump condition, the same objects will be dataized as when dataization the \ff{forward} object itself.
    \end{proof}

    \begin{eotheorem} \label{delDef}
    Object \ff{goto} without attributes \\
    \ff{forward} and \ff{backward} inside is equivalent to object \ff{seq}.
    \end{eotheorem}

    \begin{proof}
        By definition of the language, behavior of object \ff{goto} without attributes \ff{forward}/\ff{backward} inside is similar to behavior of an object \ff{seq}.
        \begin{equation}
            \begin{split}
                & \ff{goto}(\llbracket \emph{g}\,\mapsto\,\varnothing,\,\varphi\,\mapsto\,x(\alpha_1,\,\ldots\,,\,\alpha_n)\rrbracket) \\
                & \downarrow \\
                & \ff{seq}(x(\alpha_1,\,\ldots\,,\,\alpha_n))
            \end{split}
        \end{equation}
    \end{proof}

    \begin{equation*}
        \dfrac
        {\begin{split}
             & \ff{goto}(\llbracket\,\emph{g}\,\mapsto\,\varnothing,\br
             & \quad \quad \quad \varphi\,\leadsto\,x(\ldots,\br
             & \quad \quad \quad \quad k.\ff{if}(\emph{g}.\ff{forward}(y),\,z),\br
             & \quad \quad \quad \quad w,\,\ldots)\rrbracket) \\
        \end{split}}
        {\begin{split}
             & \ff{memory}(0)\,\mapsto\,flag, \\
             & \ff{seq}(\leadsto x(\ldots,\br
             & \quad \quad k.\ff{if}(\ff{seq}(y,\,flag.\ff{write}(1)),\,z),\br
             & \quad \quad \phi(w))) \\
        \end{split}}
        \jrule{2}
    \end{equation*}

    It is not difficult to notice that objects which goto-forward "jumps through" will be dataized if the condition in the if-statement is not equal to \ff{TRUE}.
    So before dataization such each object, that follows the jump, we can check condition of the jump.
    It can be done via mutable object \ff{memory} and additional \ff{if} objects.
    This is required so that all objects following the jump that are attributes of the abstract object $g$ straightforwardly or throw other objects are not dataized.
    So, by encapsulating each object, following the jump and whose \emph{nesting} is at least that of the $g$ object, in this additional \ff{if} object with a $flag$ check, we make sure that these objects will not be dataized when the jump condition is met.






    \subsection{Goto backward} \label{GB}
    Here we describe how to replace \ff{goto} object which has an attribute \ff{backward} inside to a semantic equivalent.
    Based on the concept of transformation, only cases in which attribute \ff{backward} is directly encapsulated in \ff{if} object are considered.

    When dataized, the \ff{backward} object aborts the current dataization of the \ff{goto} object and starts it again.
    In fact, such an implementation is equal to the DO-WHILE construct from other languages.
    The essence of the transformation is that we "emulate" the work of this construct.
    Since there is no such functionality in the language, we use the \ff{while} object and the mutable $flag$ object, from the result of dataization of which the loop will be dataized.

    At the beginning, we assign $flag$ object to "0". The \ff{while} object condition checks that the \ff{flag} value is equal to "0". Then in the "body" of the loop, we change the value of $flag$ to "1". If the jump condition is \ff{TRUE}, then the \ff{flag} value is required back to "0". This is necessary for the condition of the loop to be fulfilled and the next "iteration" begins.

    Same as at \ref{GF}, it is necessary to protect from dataization all objects following the \ff{if} object containing the jump, and with \emph{nesting} not less than that of the \ff{goto} object itself, since they should not be dataized when the jump condition is \ff{TRUE}.
    This requires encapsulating each such object in object \ff{if} to check the value of $flag$---i.e. whether the jump condition has been fulfilled before or not.

    Let's consider the following example of object \ff{goto} with \ff{backward} attribute:
    \begin{ffcode}
        goto
        [g]
        |$\leadsto$|x|$\label{ln:GB0}$|
        |$\alpha_1$|
        ...
        |$\alpha_n$|
        if.
        k
        g.backward
        |$\alpha_{n+1}$|
        |$\alpha_{n+2}$|
        ...
        |$\alpha_{m}$||$\label{ln:GB1}$|
    \end{ffcode}
    Applying transformation this example maps to:
    \begin{ffcode}
        memory 0 > fl|$\label{ln:TGB0}$|
        while.
        fl.eq 0
        [i]
        seq > @
        fl.write 1
        |$\leadsto$|x
        |$\alpha_1$|
        ...
        |$\alpha_n$|
        if.
        k
        fl.write 0
        |$\alpha_{n+1}$|
        if.
        fl.eq 1
        |$\alpha_{n+2}$|
        TRUE
        ...
        if.
        fl.eq 1
        |$\alpha_{m}$|
        TRUE|$\label{ln:TGB1}$|
    \end{ffcode}

    In terms of $\varphi$-calculus, lines \ref{ln:GB0}-\ref{ln:GB1} appears as:
    \begin{equation}
        \begin{split}
            & x (\alpha_1,\,\ldots\,,\,\alpha_n, \br
            & \quad k.\ff{if}(\emph{g}.\ff{backward},\,\alpha_{n+1}),\br
            & \quad \alpha_{n+2},\,\ldots\,, \alpha_m), \\
        \end{split}
    \end{equation}
    and lines \ref{ln:TGB0}-\ref{ln:TGB1} as:
    \begin{equation}
        \begin{split}
            & \ff{memory}(0)\,\mapsto\,flag, \\
            & flag.\ff{eq}(0).\ff{while}(, \br
            & \quad \ff{seq}(flag.\ff{write}(1), \br
            & \quad \quad \leadsto x (\alpha_1,\,\ldots\,,\,\alpha_n, \br
            & \quad \quad \quad \quad k.\ff{if}(flag.\ff{write}(0),\,\alpha_{n+1}), \br
            & \quad \quad \quad \quad flag.\ff{eq}(1).\ff{if}(\alpha_{n+2}),\,\ldots\,, \br
            & \quad \quad \quad \quad flag.\ff{eq}(1).\ff{if}(\alpha_{m})))) \\
        \end{split}
    \end{equation}


    \begin{eotheorem}
        Object \ff{goto} with an attribute \ff{backward} inside maps to semantically equivalent analog with mutable object, object \ff{while} and additional \ff{if} objects.
    \end{eotheorem}

    \begin{proof}
        Let's introduce the following recursive function:
        \begin{equation}
            \begin{split}
            (\forall x\,\in \emph{attr}(\emph{g})):\,\phi'(x)\,&\rightarrow\,(\mu'(x),\,\phi'(x'\,\neq\,x)) \\
            &\rightarrow\,(\mu'(x),\,(\mu'(x'),\,\phi'(x''))) \\
            &\ldots
            \end{split}
        \end{equation}
        where:
        \begin{equation}
            \begin{split}
                & \mu'(x)\,\rightarrow flag.\ff{eq}(1).\ff{if}(x) \\
            \end{split}
        \end{equation}
        Then the Ex. \ref{GBex1} maps to Ex. \ref{GBex2} according to the logic of dataization of \ff{goto} object with an attribute \ff{backward}.
        \begin{equation}\label{GBex1}
        \begin{split}
            & \ff{goto}(\llbracket\,\emph{g}\,\mapsto\,\varnothing,\br
            & \quad \quad \quad \varphi\,\leadsto\,x(\ldots,\br
            & \quad \quad \quad \quad k.\ff{if}(\emph{g}.\ff{backward},\,z),\br
            & \quad \quad \quad \quad w,\,\ldots)\rrbracket) \\
        \end{split}
        \end{equation}
        where \emph{x}, \emph{w} and \emph{z} defines any object in the language, \emph{k} defines an object, which when dataized equals to a data object \ff{TRUE}.
        \begin{equation}\label{GBex2}
        \begin{split}
            & \ff{goto}(\llbracket\,\emph{g}\,\mapsto\,\varnothing,\br
            & \quad \quad \quad \varphi\,\mapsto\,flag.\ff{eq}(0).\ff{while}(\br
            & \quad \quad \quad \quad \ff{seq}(flag.\ff{write}(1), \leadsto x(\ldots,\br
            & \quad \quad \quad \quad \quad k.\ff{if}(flag.\ff{write}(0),\,z),\br
            & \quad \quad \quad \quad \quad \phi'(w))))\rrbracket) \\
        \end{split}
        \end{equation}
        When the jump condition equals to \ff{TRUE}, all objects that should not be executed when the \ff{backward} object is executed will not be executed because of the added \ff{if} objects and since all attributes of object $g$ are encapsulated in object \ff{while}, all attributes of the object $g$ will start executing again.
    \end{proof}

    \begin{corollary}
        After transformation \emph{GB}, \ff{goto} is required to be removed to not violate parent-relations between objects.
    \end{corollary}

    \begin{proof}
        Relying on Theorem \ref{delDef}, \ff{goto} object maps to object \ff{seq}.
        But during transformation \emph{GB}, object \ff{seq} would be already created inside the object \ff{while}.
        So all bound attributes of object \ff{goto} are already inside this object \ff{seq}, and \ff{goto} now just adds two extra levels of encapsulating.

        Thus, by definition of the language, \ff{goto} object is required to be removed.
        \begin{equation}
            \begin{split}
                & \ff{goto}(\llbracket \emph{g}\,\mapsto\,\varnothing,\,\varphi\,\mapsto\,flag.\ff{eq}(0).\ff{while}(\br
                & \quad \quad \quad \ff{seq}(flag.\ff{write}(1),\,\alpha_1,\,\ldots\,,\,\alpha_n))\rrbracket) \\
                & \downarrow \\
                & flag.\ff{eq}(0).\ff{while}(\br
                & \quad \ff{seq}(flag.\ff{write}(1),\,\alpha_1,\,\ldots\,,\,\alpha_n)) \\
            \end{split}
        \end{equation}
    \end{proof}

    \begin{equation*}
        \dfrac
        {\begin{split}
             & \ff{goto}(\llbracket\,\emph{g}\,\mapsto\,\varnothing,\br
             & \quad \quad \varphi\,\leadsto\,x(\ldots,\br
             & \quad \quad \quad k.\ff{if}(\emph{g}.\ff{backward},\,z),\br
             & \quad \quad \quad w,\,\ldots)\rrbracket) \\
        \end{split}}
        {\begin{split}
             & \ff{memory}(0)\,\mapsto\,flag, \\
             & flag.\ff{eq}.(0).\ff{while}(\br
             & \quad \ff{seq}(flag.\ff{write}(1),\br
             & \quad \quad \leadsto x(\ldots,\,k.\ff{if}(flag.\ff{write}(0),\,z),\,\phi'(w)))) \\
        \end{split}}
        \jrule{3}
    \end{equation*}

    Goto-backward works the same as DO-WHILE construct in other languages: the first iteration of the new loop is always executed, and the next only if the condition of loop is TRUE.
    So, all objects that are attributes of object \ff{goto} and below the jump itself should be executed once, and all subsequent times were executed depending on the condition of the loop.

    Since there is no direct implementation this construct in EO, but there is an implementation of the \emph{while} generator, we can resort to a little trick.
    To emulate it, we can create an object \emph{flag} that will be a condition for \ff{while}, whose dataization condition will depend on this value.
    The initial value of \emph{flag} is such that the condition for the dataization of \ff{while} is fulfilled.
    Then, in the "body" of the loop, it is required to change the value of the \emph{flag} to the opposite.
    If the jump condition is \emph{TRUE}, value of \emph{flag} changes again to original so that as soon as the iteration of the loop is completed, the next iteration will begin, since the loop dataization condition will be fulfilled.

    In order to ensure that when the jump condition is \emph{TRUE}, all other objects below the jump are not executed, it is required to encapsulate them in object \ff{if}, in which will check whether the jump condition was previously been fulfilled.




    \subsection{Terminating the while-object} \label{TW}
    As mentioned above, the behavior of the \ff{while} object is different from all other objects.

    In order to realize the functionality of loops in EO, generators are provided. A generator is a routine that can be used to control the iteration behaviour of a loop.
    The language currently provides a \emph{while} generator, on which other generators are implemented.

    This transformation is an "addition" for \emph{GF}/\emph{GB} transformations since it allows to terminate the \ff{while} objects where it is required.
    It modifies the condition of executing the \ff{while} object, adding a condition so that if this condition fails, the \emph{while}-loop will be terminated.
    This could be done by creating the \ff{and} object, which implements logical \emph{AND} between attributes, and adding the desired condition and the condition of executing the \ff{while} object to its attributes.

    Consider the following code:
    \begin{ffcode}
        while.|$\label{ln:TW0}$|
        e
        x
        |$\alpha_1$|
        ...
        |$\alpha_n$||$\label{ln:TW1}$|
    \end{ffcode}
    where $\alpha_i$ and $x$ are any objects in language, $e$ is any object, which when dataized equals to a data object \ff{TRUE}.

    Suppose you want to add the following condition, which if will not be fulfilled, the loop should be terminated:
    \begin{equation}
        Z\,\neq\,0
    \end{equation}
    Applying transformation we get:
    \begin{ffcode}
        while.|$\label{ln:TTW0}$|
        and.
        eq. (Z 0)
        e
        x
        |$\alpha_1$|
        ...
        |$\alpha_n$||$\label{ln:TTW1}$|
    \end{ffcode}

    Describing transformation in terms of $\varphi$-calculus, lines \ref{ln:TW0}-\ref{ln:TW1} appears as:
    \begin{equation}
        \begin{split}
            & \emph{e}.\ff{while}(\emph{x}(\alpha_1,\,\ldots\,,\,\alpha_n)) \\
        \end{split}
    \end{equation}
    and lines \ref{ln:TTW0}-\ref{ln:TTW1} as:
    \begin{equation}
        \begin{split}
            & \emph{e}.\ff{and}(Z.\ff{eq}(0)).\ff{while}(\emph{x}(\alpha_1,\,\ldots\,,\,\alpha_n))
        \end{split}
    \end{equation}

    \begin{eotheorem}
        The dataization of object \ff{while} can be changed using additional objects that implement logical operators.
        For example, to add a condition, which if not executed, the loop will terminate, it is required to use an object \ff{and}.
    \end{eotheorem}

    \begin{proof}
        By definition of the language.
        If there is any object \emph{Z}, which returns boolean value when executed and an object \ff{while}, which dataization should stop, when this value is \emph{FALSE}, it is required to use logical operator \emph{AND} with this object:
        \begin{equation}
            \begin{split}
                & while(and(Z,\,cond_{while}),\,\ldots)\\
            \end{split}
        \end{equation}
        where the first argument is the condition for the dataization of the loop, the second argument is the "body" of the loop.
    \end{proof}

    This is used in \emph{GF}/\emph{GB} to abort the dataization of the \ff{while} object depending on the value of \ff{flag}:
    \begin{equation*}
        \dfrac
        {\begin{split}
             & e.\ff{while}(x(\alpha_1,\,\ldots\,,\,\alpha_n)) \\
        \end{split}}
        {\begin{split}
             & e.\ff{and}(flag.\ff{eq}(\emph{val})).\ff{while}(x(\alpha_1,\,\ldots\,,\,\alpha_n))
        \end{split}}
        \jrule{4}
    \end{equation*}
    where \emph{val} is a value "0" or "1", depending on type of transformation - \emph{GF}/\emph{GB}.

    It is also possible to use other objects in the language that implement logical operators such as \ff{or}, \ff{not}, \ff{xor}, etc with object \ff{while}.

%%\subsection{Final algorithm}
%%To sum up, we can now fully describe the algorithm itself. The first step is to make the transformations, if necessary, described in sections 3.1.1 and 3.2.1, depending on the current transformation. The second step is going through all the jumps in the program - forward and backward, and depending on the jump we carry out the required transformations: if needs to make a replacement in the while loop, containing a jump - use transformations 3.1.3 and 3.2.3 accordingly. If needs to make a replacement for a simple object that frames the jump - use transformations 3.1.2 and 3.2.2 respectively.

    \section{Experimental Results}

    \tbd{Here we explain how we implemented an automated tool for applying all described transformations to EO code.}

    \tbd{Then, we explain how we conducted experiments with this tool, modifying many EO programs and then running them to check whether they return the same results as original ones.}

    \section{Discussion}

    Our software will simplify programs in EO language and make them more readable without using GOTO objects.

    In addition, our proof makes it possible to remove all GOTO constructs from programs.

    \subsection{Necessity and sufficiency}
    In the above transformations, only three objects are affected - \ff{if}, \ff{while} and mutable object \ff{memory}.
    We only consider these objects, since all other objects that could implement the behavior of such constructs as \emph{DO-WHILE}, \emph{FOR}, \emph{REPEAT-UNTIL}, \emph{IF-THEN-ELSE} and others can be implemented using this objects.

    \section{Conclusion}

    As a result of our research, we suggested 4 transformations that automatically converts an input program to a semantically equivalent analog, but without using the \emph{atom} object \ff{goto}.
    We also proved that the program at the output will contain the same logic as the program at the input.


    \printbibliography %Prints bibliography
\end{document}
\endinput
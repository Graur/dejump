\documentclass[sigplan,review,11pt,nonacm,natbib=false]{acmart}
\settopmatter{printfolios=false,printccs=false,printacmref=false}
\usepackage[maxnames=1,minnames=1,maxbibnames=100,natbib=true,citestyle=authoryear,bibstyle=authoryear,doi=false,url=false,isbn=false,isbn=false,backend=biber]{biblatex}
\usepackage{debate}
\usepackage[T2A,T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian,english]{babel}
  \renewcommand\ttdefault{cmtt}
\usepackage{csquotes}
\usepackage{ffcode}
\usepackage{CJKutf8}
\usepackage{paralist}
\usepackage{cancel} % to enable \cancel command
\usepackage{anyfontsize} % To get rid of font not found warnings
\usepackage{tabularx} % for special tables
\usepackage{amsmath}
\usepackage{to-be-determined}
\usepackage{href-ul}
\usepackage{amsthm}
\usepackage{cleveref}
\usepackage{tcolorbox} % for algorithm
  \tcbuselibrary{skins}
\usepackage{fdsymbol} % for \mathbb
\usepackage{algpseudocode} % for algorithms
\usepackage{multicol} % for two cols in BNF
\usepackage{pgffor} % to enable \foreach
\usepackage{stmaryrd}
\usepackage{mathtools}
\newtheoremstyle{theorems}
  {} % Space above
  {} % Space below
  {} % Theorem body font % (default is "\upshape")
  {} % Indent amount
  {\scshape} % Theorem head font % (default is \mdseries)
  {.} % Punctuation after theorem head % default: no punctuation
  { } % Space after theorem head
  {} % Theorem head spec
\theoremstyle{theorems}
\newtheorem{eodefinition}{Definition}
\newtheorem{eotheorem}{Theorem}


\addbibresource{refs.bib}

\newcommand\br{\\[-4pt]}
\newcounter{rule}
\renewcommand\therule{R\arabic{rule}}
\newcommand\rr{\smalltriangleright{}}
\newcommand\rrule[1]{{\scshape\sffamily\ref{rule:#1}}}
\newcommand{\jrule}[1]{%
  \refstepcounter{rule}\label{rule:#1}%
  \text{\textbf{\rrule{#1}}}}

\newcommand\sgm[1]{$\sigma_#1$}
\newcommand\dlt[1]{$\delta_#1$}
\newcommand\m[1]{$\mu_#1$}

\title{Elimination Of Jump Objects}
\author{author}

\begin{document}

\maketitle

\section{Introduction}
The problem of eliminating Jump-like statements is known for both computer science and software engineering communities for a few decades and formulated by several scientists, some of which have suggested solutions for this problem.

The presence of jump statements in the source code makes it impossible to use the functional method of analysis.
Other program analysis methods, including those based on symbolic execution techniques, will also benefit from the removal of jump statements, which are well-known obstacles to the precision of analysis, as explained by \citet{baldoni2018survey}.

There are an "object-flow" languages where the execution flow is controlled by object composition.
An example of such a language is EO, which is based on $\varphi$-calculus introduced by \citet{bugayenko2021eolang} and formalized by \citet{kudasov2021}.
This is a strictly object-oriented programming language in which any action is described by creating a new object, or decorating an existing one.

We are trying to answer the following research question: "Is it possible for any program, written in 'object-flow' language like EO and containing GOTO objects, to find a semantically equivalent program, but without GOTO objects?"

\section{Related work}
The problem was firstly formulated by \citet{dijkstra1968letters}: he affirmed that the use of GOTO has disastrous effect and proposed to remove it from all programming languages.
Even though a few years later \citet{knuth1974structured} showed a manner for structuring programs with the GOTO statement and argued that it could be a powerful tool if it is well used, researchers got interested in finding a way for restructuring programs and eliminating GOTO statements \citep{arsac1977construction}.

To solve the problem of eliminating Jump-like statements in other programming languages, the following works were published:
\Citet{williams1985restructuring} created a tool for restructuring Pascal code;
\Citet{jonsson1989next} was one of the first who made a summary of so called GOTO-patches, which are design techniques for eliminating GOTO statements;
\Citet{erosa1994taming} suggested an algorithm for automatic elimination of GOTO statements in~C;
\Citet{zegour1994new} explained how GOTO elimination may work in any language, as long as it has jump statements and control structures;
\Citet{morris1997goto} suggested to use regular expressions for replacing GOTO with IF-THEN-ELSE constructs;
\Citet{ramshaw1988eliminating} proposed an algorithm for Pascal programs;
\Citet{ganapathi2008shim} introduced optimization method for SHIM IR;
\Citet{ceccato2008goto} suggested how to eliminate GOTO during migration of legacy code to Java.

However, to our knowledge, there is still no method available, which enables automatic elimination of jump objects in programs written in such an object-flow languages.


\section{Definitions and designations}
\begin{eodefinition}
\emph{Dataization} in $\varphi$-calculus is a process of retrieving data from an object.
The dataization of an object at the highest level of composition is similar to the execution of a program in other languages.
\end{eodefinition}
\begin{eodefinition} \emph{Nesting} of the current object determines the number of objects that encapsulate current object via abstraction, application, or decoration directly or through other objects.
For example, here object $x$ has 3-rd level of nesting:
\begin{ffcode}
o1
  o2
  ...
  o3
    o4
      x
\end{ffcode}
\end{eodefinition}
\begin{eodefinition}
\emph{Forwarding goto} denotes an object \ff{goto}, which encapsulate object \ff{forward} directly or through other objects:
\begin{ffcode}
goto
  [o1]
  |$\leadsto$|o1.forward o
\end{ffcode}
\end{eodefinition}
\begin{eodefinition}
\emph{Backwarding goto} denotes an object \ff{goto}, which encapsulate object \ff{backward} directly or through other objects:
\begin{ffcode}
goto
  [o1]
  |$\leadsto$|o1.backward
\end{ffcode}
\end{eodefinition}

Let's look at an EO code example that demonstrates the general syntax of the language:
\begin{ffcode}
memory 0 > x
[] > app
  [a b] > max
    goto > @
      [g]
        if. > @
          a.gt b
          g.forward a
          b
  [x] > run
    while. > @!
      and.
        x.lt 10
        (x.mod 1).eq 0
      [i]
        x.write > @
          (x.plus 1)
\end{ffcode}
In this code snippet, \ff{goto} is an \emph{atom}-object with attribute \ff{g}, which dataizes similar to \ff{seq} object;
\ff{memory} is mutable object, which allows to reinitialize the bound object \ff{x} via \ff{.write} attribute;
\ff{eq} is an object, which checks the equality of the objects passed to it;
\ff{if} is an object, which implements behavior of branching;
\ff{seq} is an object that sequentially dataizes all objects within it;
\ff{while} is an object, implementing behavior of loops: its first bound attribute implements condition of loop dataization and second one implies "body" of loop;
\ff{backward} and \ff{forward} are objects, which implements behaviour of jumps: first of them starts dataization of object \ff{g} again, while the second one returns the object passed to it as a parameter and terminates the dataization of the \ff{goto} object.

In terms of $\varphi$-calculus, code snipped above will be presented as:
\begin{equation}
\begin{split}
& app \mapsto \llbracket \br
& \quad max(a, b) \mapsto \llbracket \br
& \quad \quad \varphi \mapsto \ff{goto}(\llbracket\,g\,\mapsto\,\varnothing,\br
& \quad \quad \quad \varphi \mapsto a.\ff{gt}(b).\ff{if}(g.\ff{forward}(a), b) \br
& \quad \quad \rrbracket) \br
& \quad \rrbracket \br
& \quad run(x) \mapsto \llbracket \br
& \quad \quad \varphi\ff{!} \mapsto x.\ff{lt}(10).\ff{and}(x.\ff{mod}(1).\ff{eq}(0)) \br
& \quad \quad \quad \quad .\ff{while}(\llbracket i \mapsto \varnothing, \br
& \quad \quad \quad \quad \quad \quad \quad \quad \varphi \mapsto x.\ff{write}(x.\ff{plus}(1)) \br
& \quad \quad \quad \quad \quad \rrbracket) \br
& \quad \rrbracket \br
& \rrbracket \\
\end{split}
\end{equation}

\emph{Designations:}
\begin{itemize}
\item "$>$" is used to name objects, where on the left side of ">" is object itself and its name on the right side,
\item "$[]$" is used to specify object parameters,
\item "$@$" is used to denote the object being decorated,
\item "$!$" is used to declare the object as a constant,
\item "$\mapsto$" is used to denote an object, where free attributes stay in the parentheses on the left side and pairs, which represent bound attributes, stay on the right side, in double-square brackets,
\item "$\leadsto$" denotes an arbitrary \emph{nesting} of an object, i.e. it can be encapsulated by other objects directly or via chain of objects.
\end{itemize}


\section{Sample}
Let's consider the following example of C++ code, which uses goto:
\begin{ffcode}
int x = 0;|$\label{ln:cpp0}$|
int func() {
l1:
  x = x + 1;
  if (x < 10)
    goto l1;
  else
    cout << "X >= 10!\n";
  return x;
}|$\label{ln:cpp1}$|
\end{ffcode}

We provide four independent transformations that replace \ff{goto} with a semantically equivalent analogue.
After applying them, example above respresents as:
\begin{ffcode}
int fl_1 = 0;|$\label{ln:tcpp0}$|
int fl_2 = -1;
int x = 0;
int func() {
  fl_1 = 0;
  fl_2 = -1;
  do {
    fl_1 = 1;
    fl_2 = 0;
    x = x + 1;
    if (x < 10)
      fl_1 = 0;
    else
      cout << "X >= 10!\n";
    if (fl_1 == 1)
      fl_2 = 1;
  } while (fl_1 == 0 |$\vert$||$\vert$| fl_2 == -1);
  if (fl_2 == 1)
    return x;
}|$\label{ln:tcpp1}$|
\end{ffcode}

Since we consider the problem of eliminating Jump-like statements on the example of a strictly object-oriented language EO, lines ~\ref{ln:cpp0}--~\ref{ln:cpp1} will be represented as:
\begin{ffcode}
memory 0 > x
[] > func
  goto > @
    [g]
      seq > @
        x.write (x.plus 1)
        if.
          x.lt 10
          g.backward
          QQ.io.stdout "X >= 10!\n"
        g.forward x
\end{ffcode}

While this code after transformations will appear as:
\begin{ffcode}
memory 0 > fl_1
memory -1 > fl_2
memory 0 > x
[] > func
  seq > @
    fl_1.write 0
    fl_2.write -1
    while. > rem!
      or.
        fl_1.eq 0
        fl_2.eq -1
      [i]
        seq > @
          fl_1.write 1
          fl_2.write 0
          x.write (x.plus 1)
          if.
            x.lt 10
            fl_1.write 0
            QQ.io.stdout "X >= 10!\n"
          if.
            fl_1.eq 1
            fl_2.write 1
            TRUE
    if.
      fl_2.eq 1
      x
      rem
\end{ffcode}

Thus, the main purpose of our research is:
\begin{enumerate}
    \item To formulate inference rules for the transformations that we propose,
    \item proof that these 4 transformations are necessary and sufficient to solve the problem under consideration,
    \item suggest a program tool, which
    enables automatic elimination of jump objects in programs written in EO.
\end{enumerate}



\section{Method}
In this article, we will describe an algorithm that will convert an EO program in such a way that the output returns a semantically equivalent program, but without using the GOTO object.

Some objects in EO may need to be platform specific and can’t be composed from other existing objects — they are called \emph{atoms}. 
All jump statements are implemented as a
single \emph{atom}-object \ff{goto}.
The implementation of \ff{goto} in EO implies two types of jumps - forward jump and backward jump.
It is required to cover all possible cases for both of them.

%%The proposed algorithm is a series of transformations that are performed depending on the type of "jump".
In total, we describe 4 types of transformations:
\begin{inparaenum}[1)]
\item \emph{Simple goto} (further $SG$),
\item \emph{Goto to While} (further $GTW$) and
\item \emph{Goto forward/backward} (further $GF$/$GB$).
\end{inparaenum}
Transformations are independent and not sequential, and each one is executed in its own particular case.
For example, $SG$ and $GTW$ are only a "preparation" for the actual replacement of the jump by a semantically equivalent analog.
First one is executed if there is no condition before the jump itself, while second one transforms object \ff{goto} into object \ff{while}.
$GF$/$GB$ are the main transformations, as they contain the jump replacement itself and cover most possible cases of using forward and backward jumps.
%%\emph{TW} is an "addition" for $GF$ and $GB$ transformations, since the behavior of the \ff{while} object in EO is different from all other objects and dataization of jump inside the loop requires separate consideration.


%%Thus, the algorithm itself consists of the following steps: 
%%\begin{inparaenum}[1)]
%%\item Apply \emph{SF}/\emph{SB} transformation if necessary,
%%\item Find all occurrences of forward/backward jump's calls,
%%\item Apply $GF$/$GB$ transformations to all of them,
%%\item If there is a \emph{while.} object that wraps the jump call, apply the \emph{WF}/\emph{WB} transformation.
%%\end{inparaenum}

The combination of all 4 transformations implies a complete algorithm for getting rid of the GOTO object, as they cover all possible cases of using GOTO and forward/backward jumps in the language.

Since we consider a solution to the problem in strictly object-oriented programming languages, which means that the whole program is a set of objects where some objects can encapsulate others.
It should be noted that each object in the program has its own level of \emph{nesting} relative to other objects.

We will also consider our transformations in the form of $\varphi$-calculus, on which EO is based.
The proposed $\varphi$-calculus represents an object model through data and objects, while operations with them are possible through abstraction, application and decoration.
The calculus introduces a formal apparatus for manipulations with objects.




\subsection{Simple goto} \label{SG}
As mentioned above, this transformation is a "preparation" for $GF$/$GB$ which are make the replacement of object \ff{goto} itself.
Since $GF$/$GB$ only consider the use of the \ff{forward}/\ff{backward} objects when they are directly encapsulated in the \ff{if} object(\cref{GF}/\cref{GB}), it is required to add an additional \ff{if} when it is absent before the jump.
Thus, the transformation under consideration adds an additional fictitious condition $\emph{if (true)}$ if it necessary.

Let's consider the case where the \ff{forward} is not directly encapsulated in the \ff{if} object:
\begin{ffcode}
goto
  [g]
   |$\leadsto$|g.forward y|$\label{ln:sf1}$|
\end{ffcode}
Here, $\alpha_{i}$, $x$ and $y$ defines any object in the language, excluding \ff{if}.

Applying the transformation, the example above maps to:
\begin{ffcode}
goto
  [g]
   |$\leadsto$|if.|$\label{ln:tsf0}$|
      TRUE
      g.forward y
      TRUE|$\label{ln:tsf1}$|
\end{ffcode}

Describing transformation in terms of $\varphi$-calculus, code at line ~\ref{ln:sf1} will be represented as:
\begin{equation}
\begin{split}
& g.\ff{forward}( y ) \\
\end{split}
\end{equation}
and code at lines ~\ref{ln:tsf0}---\ref{ln:tsf1} as:
\begin{equation}
\begin{split}
& \ff{TRUE}.\ff{if}(g.\ff{forward}( y )) \\
\end{split}
\end{equation}

\begin{eotheorem}
Any object is semantically equivalent to the same object encapsulated in \ff{TRUE}.\ff{if}:
\begin{equation*}
\forall x (x \equiv \ff{TRUE}.\ff{if}(x)).
\end{equation*}
\end{eotheorem}

\begin{proof}
By definition of the language, if there is any object \emph{Z}, then the following equivalence follows:
\begin{equation}
Z \equiv if(true,\,Z,\,true),
\end{equation}
where first argument in \emph{if} is condition itself, second argument dataizes when condition is \emph{true} and third argument dataizes when condition is \emph{false}.
\end{proof}

\begin{equation*}
\dfrac
    {\begin{split}
    & g.\ff{forward}( y ) \\
    \end{split}}
    {\begin{split}
    & \ff{TRUE}.\ff{if}(g.\ff{forward}( y )) \\
    \end{split}}
    \jrule{1}
\end{equation*}

%%Note that in this example, \ff{forward} is simply an attribute of the abstract object \emph{g} and is dataized as soon as the queue reaches it.
In such cases where there is an "unconditional" jump, first of all we transform it into "conditional" jump by encapsulating it in additional object \ff{if}---\emph{if (true)}.
This will not violate the program logic, since added condition will always be \emph{TRUE} and "THEN" brunch of if-statement with object \ff{forward} will always be dataized.

The same logic applies with the \ff{backward} object.



\subsection{Goto forward} \label{GF}
In this section, we discuss the transformation by replacing \emph{forwarding goto} with a semantic equivalent.
Based on the concept of transformation, only cases in which \ff{forward} is directly encapsulated in the object \ff{if} are considered.

The essence of the transformation is that we create an additional $flag$ object which will assign as "0" or "1" and will show whether the jump condition has been met.
Instead of dataization \ff{forward}, we just reinitialize the $flag$ object with another value of data object \ff{Int}.
Moreover, it is necessary to protect from dataization all objects inside \ff{goto} that follows the jump, since they should not be dataized when the jump condition is \ff{TRUE}.
This requires encapsulating each such object with an additional object \ff{if} to check the equality $flag$ to an object "1"---i.e. whether the jump condition has been met before or not.

Let's consider the following example:
\begin{ffcode}
goto|$\label{ln:of0}$|
  [g]
   |$\leadsto$|if.
      k
      g.forward y
      |$\alpha_{n}$||$\label{ln:of1}$|
\end{ffcode}
Here, $\alpha_i$, $x$ and $y$ defines any object in the language; $k$ defines an object, which when dataized equals to a data object \ff{TRUE}/\ff{FALSE}.

Applying the transformation, the example above maps
to:
\begin{ffcode}
memory -1 > flag
seq|$\label{ln:tof0}$|
  goto > rem!
    [g]
     |$\leadsto$|if.
        k
        flag.write 1
        |$\alpha_{n+1}$|
  if.
    flag.eq 1
    y
    rem|$\label{ln:tof1}$|
\end{ffcode}

In terms of $\varphi$-calculus lines ~\ref{ln:of0}--\ref{ln:of1} appears as:
\begin{equation}
\begin{split}
& \ff{goto}(\llbracket g\,\mapsto\,\varnothing,\br
& \quad \quad \quad \varphi\,\mapsto\,(\,\leadsto k.\ff{if}(g.\ff{forward}(y), \alpha_{n+1}), \br
& \quad \quad \quad \rrbracket) \\
\end{split}
\end{equation}
Lines ~\ref{ln:tof0}--\ref{ln:tof1} will be represented as:
\begin{equation}
\begin{split}
& \ff{seq}(\ff{goto}(\llbracket g\,\mapsto\,\varnothing,\br
& \quad \quad \quad \quad \quad \varphi\,\mapsto\,(\,\leadsto x(\alpha_1\,\ldots\,\alpha_n, \br
& \quad \quad \quad \quad \quad \quad \quad k.\ff{if}(flag.\ff{write}(1),\,\alpha_{n+1}), \br
& \quad \quad \quad \quad \quad \quad \quad \Theta(\alpha_{n+2}),\,\ldots\,,\,\Theta(\alpha_m)),\ldots\Theta(\alpha_{m+1})) \br
& \quad \quad \quad \quad \quad \rrbracket)\mapsto rem\ff{!}, \br
& \quad \quad flag.\ff{eq}(1).\ff{if}(y,\,rem)) \\
\end{split}
\end{equation}
Here,
\begin{equation}
\Theta(X) \equiv flag.\ff{eq}(0).\ff{if}(X,\,\ff{TRUE})
\end{equation}

\begin{eotheorem}
\emph{Forwarding goto} maps to semantically equivalent analog without \ff{forward} objects:
\begin{equation*}
\begin{split}
& \ff{goto}(\llbracket g\,\mapsto\,\varnothing,\,\varphi\,\leadsto\,x(\ldots,\,\leadsto g.\ff{forward}(y),\,\ldots)\rrbracket) \\
& \downarrow \\
& \ff{seq}( \br
& \quad \quad \ff{goto}(\llbracket g\,\mapsto\,\varnothing,\br
& \quad \quad \quad \quad \quad \varphi\,\leadsto\,x(\ldots,\,\leadsto flag.\ff{write}(1),\,\ldots)\br
& \quad \quad \quad \quad \quad \rrbracket)\mapsto rem\ff{!}, \br
& \quad \quad flag.\ff{eq}(1).\ff{if}(y,\,rem)) \\
\end{split}
\end{equation*}
\end{eotheorem}

\begin{proof}
Let's introduce the following recursive function:
\begin{equation}
\begin{split}
(\forall x\,\in\,\emph{attr}(\emph{g})):\,\mu(x)\,&\rightarrow\,(\Theta(x),\,\mu(x'\,\neq\,x)) \\
        &\rightarrow\,(\Theta(x),\,(\Theta(x'),\,\mu(x''))) \\
        &\ldots
\end{split}
\end{equation}
Here, $attr(X)$ denotes all attributes of an object $X$.

Since the object \ff{goto} without \ff{forward} inside dataizes similar to the object \ff{seq}, then it follows that the following expression is valid:
\begin{equation}
\begin{split}
& \ff{goto}(\llbracket g\,\mapsto\,\varnothing,\br
& \quad \quad \varphi\,\leadsto\,x(\alpha_1,\,\ldots\,,\alpha_n)\rrbracket) \equiv \\
& \ff{seq}(\ff{goto}(\llbracket g\,\mapsto\,\varnothing,\br
& \quad \quad \varphi\,\leadsto\,x(\alpha_1,\,\ldots\,,\alpha_n)\rrbracket)),\\
\end{split}
\end{equation}
Here, $alpha_n$ defines any object in the language, excluding object \ff{forward}.

When the outer \ff{seq} dataizes object \ff{goto} and the jump condition is \ff{TRUE}, it must return as a result of dataization the attribute of an object \ff{forward}.
It can be done by the \ff{if} object, that follows object \ff{goto} and checks equality of $flag$ object to "1".

According to the logic of dataization and definition of the language, both cases of dataization object \ff{forward} are considered via added \ff{if} objects.
\debate[Mikhail]{Need a STRONG proof!}
\end{proof}

\begin{equation*}
\dfrac
    {\begin{split}
    & \ff{goto}(\llbracket\,g\,\mapsto\,\varnothing,\br
    & \quad \quad \quad \varphi\,\leadsto\,x(\ldots,\,k.\ff{if}(g.\ff{forward}(y),\,z),\br
    & \quad \quad \quad w,\,\ldots)\rrbracket) \\
    \end{split}}
    {\begin{split}
    & \ff{seq}(\ff{goto}(\llbracket g\,\mapsto\,\varnothing,\br
    & \quad \quad \quad \quad \quad \varphi\,\leadsto\,x(\ldots,\,k.\ff{if}(flag.\ff{write}(1),\,z), \br
    & \quad \quad \quad \quad \quad \quad \quad \mu(w),\,\ldots\,) \br
    & \quad \quad \quad \quad \quad \rrbracket)\mapsto rem\ff{!}, \br
    & \quad \quad flag.\ff{eq}(1).\ff{if}(y,\,rem)) \\
    \end{split}}
    \jrule{2}
\end{equation*}
Here, $x$, $w$, $y$ and $z$ defines any object in the language, $k$ defines an object, which when dataized equals to a data object \ff{TRUE}.

Indeed, depending on the jump condition, the same objects will be dataized as when dataization the \ff{forward} object itself.

It is not difficult to notice that objects which goto-forward "jumps through" will be dataized if the condition in the if-statement is not equal to \ff{TRUE}.
So before dataization such each object, that follows the jump, we can check condition of the jump.
It can be done via mutable object \ff{memory} and additional \ff{if} objects.
This is required so that all objects following the jump that are attributes of the abstract object $g$ straightforwardly or throw other objects are not dataized.
So, by encapsulating each object, following the jump and whose \emph{nesting} is at least that of the $g$ object, in this additional \ff{if} object with a $flag$ check, we make sure that these objects will not be dataized when the jump condition is met.



\subsection{Goto to While} \label{GTW}
As mentioned above, all transformations are sequential.
A necessary condition for the $GTW$ transformation is the absence of \ff{forward}/\ff{backward} objects inside the \ff{goto} object.
In other words, this transformation is applied directly along with $GF$ and $GB$, since they imply the replacement of \ff{forward} and \ff{backward} objects.
The essence of the transformation is that the object \ff{goto} maps to a control-flow object \ff{while}.

Let's consider an example where inside the \ff{goto} object, the \ff{forward}/\ff{backward} objects are replaced with a semantic equivalent:
\begin{ffcode}
memory -1 > flag
seq|$\label{ln:gtw0}$|
  goto > rem!
    [g]
     |$\leadsto$|x
        |$\alpha_1$|
        ...
        |$\alpha_n$|
        if.
          k
          flag.write 1
          |$\alpha_{n+1}$|
        if.
          flag.eq 0
          |$\alpha_{n+2}$|
          TRUE
        ...
        if.
          flag.eq 0
          |$\alpha_{m}$|
          TRUE
  if.
    flag.eq 1
    y
    rem|$\label{ln:gtw1}$|
\end{ffcode}
Here, $\alpha_{i}$, $y$ and $x$ defines any object in the language, excluding \ff{forward}/\ff{backward};
$k$ defines an object, which when dataized equals to a data object \ff{TRUE}/\ff{FALSE}.

Applying the transformation, the example above maps
to:
\begin{ffcode}
memory -1 > flag
seq|$\label{ln:tgtw0}$|
  while. > rem!
    flag.eq -1
    [i]
      seq > @
        flag.write 0
        |$\leadsto$|x
          |$\alpha_1$|
          ...
          |$\alpha_n$|
          if.
            k
            flag.write 1
            |$\alpha_{n+1}$|
          if.
            flag.eq 0
            |$\alpha_{n+2}$|
            TRUE
          ...
          if.
            flag.eq 0
            |$\alpha_{m}$|
            TRUE
  if.
    flag.eq 1
    y
    rem|$\label{ln:tgtw1}$|
\end{ffcode}

In terms of $\varphi$-calculus lines ~\ref{ln:gtw0}--\ref{ln:gtw1} appears as:
\begin{equation}
\begin{split}
& \ff{seq}(\ff{goto}(\llbracket g\,\mapsto\,\varnothing,\br
& \quad \quad \quad \quad \quad \varphi\,\mapsto\,(\,\leadsto x(\alpha_1\,\ldots\,\alpha_n, \br
& \quad \quad \quad \quad \quad \quad \quad k.\ff{if}(flag.\ff{write}(1),\,\alpha_{n+1}), \br
& \quad \quad \quad \quad \quad \quad \quad \Theta(\alpha_{n+2}),\,\ldots\,,\,\Theta(\alpha_m))) \br
& \quad \quad \quad \quad \quad \rrbracket)\mapsto rem\ff{!}, \br
& \quad \quad flag.\ff{eq}(1).\ff{if}(y,\,rem)) \\
\end{split}
\end{equation}
Here, $alpha_n$ defines any object in the language, excluding objects \ff{forward} and \ff{backward}.

Lines ~\ref{ln:tgtw0}--\ref{ln:tgtw1} will be represented as:
\begin{equation}
\begin{split}
& \ff{seq}(flag.\ff{eq}(-1).\ff{while}(\llbracket i\,\mapsto\,\varnothing,\br
& \quad \quad \quad \quad \quad \quad \quad \quad \varphi\,\mapsto\,(\ff{seq}(flag.\ff{write}(0), \br
& \quad \quad \quad \quad \quad \quad \quad \quad \quad \leadsto x(\alpha_1\,\ldots\,\alpha_n, \br
& \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad k.\ff{if}(flag.\ff{write}(1),\,\alpha_{n+1}), \br
& \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \Theta(\alpha_{n+2}),\,\ldots\,,\,\Theta(\alpha_m)))) \br
& \quad \quad \quad \quad \quad \quad \quad \quad \rrbracket)\mapsto rem\ff{!}, \br
& \quad \quad flag.\ff{eq}(1).\ff{if}(y,\,rem)) \\
\end{split}
\end{equation}

\begin{eotheorem}
Object \ff{goto} maps to object \ff{while} if there are no \ff{forward}/\ff{backward} objects inside of it:
\begin{equation*}
\begin{split}
& \ff{goto}(\llbracket g\,\mapsto\,\varnothing,\,\varphi\,\leadsto\,x(\alpha_1,\,\ldots\,,\alpha_n)\rrbracket) \\
& \downarrow \\
& Z.\ff{while}(\llbracket i\,\mapsto\,\varnothing,\,\varphi\,\mapsto(\leadsto\,x(\alpha_1,\,\ldots\,,\alpha_n))\rrbracket) \\
\end{split}
\end{equation*}
\end{eotheorem}
Here, $Z$ is an object, which, when dataized, will be equal to a data object \ff{TRUE} only once.

\begin{proof}
By definition of the language, if there are no \ff{forward} and \ff{backward} objects inside object \ff{goto}, it dataizes similar to object \ff{seq}.
It follows that the \ff{goto} object can be mapped to object \ff{while} with a condition, that will be equal to a data object \ff{TRUE} once, without violating the program logic.
\end{proof}

\begin{equation*}
\dfrac
    {\begin{split}
    & \ff{seq}(\ff{goto}(\llbracket g\,\mapsto\,\varnothing,\br
    & \quad \quad \quad \quad \quad \varphi\,\mapsto\,(\,\leadsto x(\alpha_1\,\ldots\,\alpha_n, \br
    & \quad \quad \quad \quad \quad \quad \quad k.\ff{if}(flag.\ff{write}(1),\,\alpha_{n+1}), \br
    & \quad \quad \quad \quad \quad \quad \quad \Theta(\alpha_{n+2}),\,\ldots\,,\,\Theta(\alpha_m))) \br
    & \quad \quad \quad \quad \quad \rrbracket)\mapsto rem\ff{!}, \br
    & \quad \quad flag.\ff{eq}(1).\ff{if}(y,\,rem)) \\
    \end{split}}
    {\begin{split}
    & \ff{seq}(flag.\ff{eq}(-1).\ff{while}(\llbracket i\,\mapsto\,\varnothing,\br
    & \quad \quad \quad \quad \quad \quad \quad \quad \varphi\,\mapsto\,(\ff{seq}(flag.\ff{write}(0), \br
    & \quad \quad \quad \quad \quad \quad \quad \quad \quad \leadsto x(\alpha_1\,\ldots\,\alpha_n, \br
    & \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad k.\ff{if}(flag.\ff{write}(1),\,\alpha_{n+1}), \br
    & \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \Theta(\alpha_{n+2}),\,\ldots\,,\,\Theta(\alpha_m)))) \br
    & \quad \quad \quad \quad \quad \quad \quad \quad \rrbracket)\mapsto rem\ff{!}, \br
    & \quad \quad flag.\ff{eq}(1).\ff{if}(y,\,rem)) \\
    \end{split}}
    \jrule{3}
\end{equation*}

The transformation does not violate the logic of the program, however, it gives the opportunity to dataize the "body" of the \ff{while} object loop again, if necessary.
This trick is used in the $GB$ transformation.




\subsection{Goto backward} \label{GB}
Here we describe how to replace \ff{goto} object which has an object \ff{backward} inside to a semantic equivalent.
Based on the concept of transformation, only cases in which attribute \ff{backward} is directly encapsulated in \ff{if} object are considered and this transformation is applied directly with $GTW$.

When dataized, the \ff{backward} object aborts the current dataization of the \ff{goto} object and starts it again.
In fact, such an implementation is equal to the DO-WHILE construct from other languages.
The essence of the transformation is that we "emulate" the work of this construct.
Since there is no such functionality in the language, we use the \ff{while} object and the mutable $flag$ object, from the result of dataization of which the loop will be dataized.

At the beginning, we assign $flag$ object to a data object \ff{Int} equal to "0".
The \ff{while} object condition checks that the \ff{flag} value is equal to "0" of data object \ff{Int}.
Then in the "body" of the loop, we change $flag$ to "1".
If the jump condition is \ff{TRUE}, then the \ff{flag} is required back to "0".
This is necessary for the condition of the loop to be fulfilled and the next "iteration" begins.

Same as at \ref{GF}, it is necessary to protect from dataization all objects inside \ff{goto} that follows the jump, since they should not be dataized when the jump condition is \ff{TRUE}.
This requires encapsulating each such object in object \ff{if} to check $flag$---i.e. whether the jump condition was \ff{TRUE} before or not.

Let's consider the following example of object \ff{goto} with \ff{backward} inside:
\begin{ffcode}
goto|$\label{ln:GB0}$|
  [g]
   |$\leadsto$|x
      |$\alpha_1$|
      ...
      |$\alpha_n$|
      if.
        k
        g.backward
        |$\alpha_{n+1}$|
      |$\alpha_{n+2}$|
      ...
      |$\alpha_{m}$||$\label{ln:GB1}$|
\end{ffcode}
Applying transformation $GB$ with $GTW$ this example maps to:
\begin{ffcode}
memory 0 > flag
while.|$\label{ln:TGB0}$|
  flag.eq 0
  [i]
    seq > @
      flag.write 1
       |$\leadsto$|if.
          k
          flag.write 0
          |$\alpha_{n}$||$\label{ln:TGB1}$|
\end{ffcode}

In terms of $\varphi$-calculus, lines \ref{ln:GB0}--\ref{ln:GB1} appears as:
\begin{equation}
\begin{split}
& \ff{goto}(\llbracket g\,\mapsto\,\varnothing,\br
& \quad \quad \quad \varphi\,\mapsto\,(\,\leadsto x(\alpha_1\,\ldots\,\alpha_n, \br
& \quad \quad \quad \quad \quad k.\ff{if}(g.\ff{backward}, \alpha_{n+1}), \br
& \quad \quad \quad \quad \quad \alpha_{n+2},\,\ldots\,,\,\alpha_m))\rrbracket) \\
\end{split}
\end{equation}
Lines \ref{ln:TGB0}--\ref{ln:TGB1} as:
\begin{equation}
\begin{split}
& \ff{seq}(flag.\ff{eq}(0).\ff{while}(\llbracket i\,\mapsto\,\varnothing,\br
& \quad \quad \quad \quad \quad \quad \quad \quad \varphi\,\mapsto\,(\ff{seq}(flag.\ff{write}(1), \br
& \quad \quad \quad \quad \quad \quad \quad \quad \quad \leadsto x(\alpha_1\,\ldots\,\alpha_n, \br
& \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad k.\ff{if}(flag.\ff{write}(0),\,\alpha_{n+1}), \br
& \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \Upsilon(\alpha_{n+2}),\,\ldots\,,\,\Upsilon(\alpha_m)))) \br
& \quad \quad \quad \quad \quad \quad \quad \quad \rrbracket)\mapsto rem\ff{!}, \br
& \quad \quad flag.\ff{eq}(1).\ff{if}(y,\,rem)) \\
\end{split}
\end{equation}
Here,
\begin{equation}
\Upsilon(X) \equiv flag.\ff{eq}(1).\ff{if}(X,\,\ff{TRUE})
\end{equation}

\begin{eotheorem}
\emph{Backwarding goto} maps to semantically equivalent analog without \ff{backward} objects:
\begin{equation*}
\begin{split}
& \ff{goto}(\llbracket g\,\mapsto\,\varnothing,\,\varphi\,\leadsto\,x(\ldots,\,\leadsto g.\ff{backward},\,\ldots)\rrbracket) \\
& \downarrow \\
& \ff{seq}( \br
& \quad \quad flag.\ff{eq}(0).\ff{while}(\llbracket g\,\mapsto\,\varnothing,\br
& \quad \quad \quad \quad \quad \varphi\,\leadsto\,x(\ldots,\,\leadsto flag.\ff{write}(1),\,\ldots)\br
& \quad \quad \quad \quad \quad \rrbracket)\mapsto rem\ff{!}, \br
& \quad \quad flag.\ff{eq}(1).\ff{if}(y,\,rem)) \\
\end{split}
\end{equation*}
\end{eotheorem}

\begin{proof}
Let's introduce the following recursive function:
\begin{equation}
\begin{split}
(\forall x\,\in\,\emph{attr}(\emph{g})):\,\mu'(x)\,&\rightarrow\,(\Upsilon(x),\,\mu'(x'\,\neq\,x)) \\
        &\rightarrow\,(\Upsilon(x),\,(\Upsilon(x'),\,\mu'(x''))) \\
        &\ldots
\end{split}
\end{equation}

Since this transformation is applied directly with $GTW$, then \ff{goto} object is already mapped to object \ff{while}.
Based on logic of dataization of an object \\
\ff{backward}, it is required to emulate dataization of object again.
This can easily be done via the \ff{while} loop added to the $GTW$ transformation by changing its dataization condition:
\begin{equation}
\begin{split}
& \ff{goto}(\llbracket g\,\mapsto\,\varnothing,\br
& \quad \quad \varphi\,\leadsto\,x(\alpha_1,\,\ldots\,g.\ff{backward},\,\ldots\,,\alpha_n)\rrbracket) \equiv \\
& \ff{seq}(flag.\ff{eq}(0).\ff{while}(\llbracket i\,\mapsto\,\varnothing,\br
& \quad \quad \varphi\,\leadsto\,x(\alpha_1,\,\ldots\,,flag.\ff{write}(1),\,\ldots\,,\Upsilon(\alpha_n))\rrbracket)),\\
\end{split}
\end{equation}
Here, $alpha_n$ defines any object in the language, excluding object \ff{forward}.

Based on the $GF$ and $GTW$ transformations, this transformation is valid by the definition of the language.
\debate[Mikhail]{Need a STRONG proof!}
\end{proof}

\begin{equation*}
\dfrac
    {\begin{split}
    & \ff{goto}(\llbracket g\,\mapsto\,\varnothing,\br
    & \quad \quad \quad \varphi\,\mapsto\,(\,\leadsto x(\alpha_1\,\ldots\,\alpha_n, \br
    & \quad \quad \quad \quad \quad k.\ff{if}(g.\ff{backward},\,\alpha_{n+1}), \br
    & \quad \quad \quad \quad \quad \Upsilon(\alpha_{n+2}),\,\ldots\,,\,\Upsilon(\alpha_m))) \br
    & \quad \quad \quad \rrbracket)\mapsto rem\ff{!}, \br
    & \quad \quad flag.\ff{eq}(1).\ff{if}(y,\,rem) \\
    \end{split}}
    {\begin{split}
    & \ff{seq}(flag.\ff{eq}(0).\ff{while}(\llbracket i\,\mapsto\,\varnothing,\br
    & \quad \quad \quad \quad \quad \quad \quad \quad \varphi\,\mapsto\,(\ff{seq}(flag.\ff{write}(1), \br
    & \quad \quad \quad \quad \quad \quad \quad \quad \quad \leadsto x(\alpha_1\,\ldots\,\alpha_n, \br
    & \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad k.\ff{if}(flag.\ff{write}(0),\,\alpha_{n+1}), \br
    & \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \Upsilon(\alpha_{n+2}),\,\ldots\,,\,\Upsilon(\alpha_m)))) \br
    & \quad \quad \quad \quad  \quad \quad \quad \quad \quad \quad \rrbracket)) \\
    \end{split}}
    \jrule{4}
\end{equation*}

Goto-backward works the same as DO-WHILE construct in other languages: the first iteration of the new loop is always executed, and the next only if the condition of loop is TRUE.
So, all objects that inside of object \ff{goto} and below the jump itself should be executed once, and all subsequent times were executed depending on the condition of the loop.

Since there is no direct implementation this construct in EO, but there is an implementation of the \emph{while} generator, we can resort to a little trick.
To emulate it, we can create an object $flag$ that will be a condition for \ff{while}, whose dataization condition will depend on this object.
We initialize $flag$ is such that the condition for the dataization of \ff{while} is fulfilled.
Then, in the "body" of the loop, it is required to change $flag$ to the opposite.
If the jump condition is \ff{TRUE}, $flag$ changes again to original so that as soon as the iteration of the loop is completed, the next iteration will begin, since the loop dataization condition will be \ff{TRUE}.

In order to ensure that when the jump condition is \ff{TRUE}, all other objects below the jump are not executed, it is required to encapsulate them in object \ff{if}, in which will check whether the jump condition was previously been \ff{TRUE}.


\section{Restrictions}
Based on the concept of strictly object-oriented programming languages like EO, it is not possible to get rid of \ff{forward}/\ff{backward} objects in all cases.
In such languages, some constructs are impossible to be exactly converted into code in functional languages such as Java, C++, Python, and others.

Let's consider the following example of using \ff{goto} object:
\begin{ffcode}
goto
  [g]
    seq > @
      foo g
[x] > foo
  x.forward 25
\end{ffcode}
In this case, the object $g$, from which the \ff{forward}/\ff{backward} objects are called, is passed as an argument to another object, and the \ff{forward} object is already will be dataized inside object $foo$.

Similarly, if the \ff{forward}/\ff{backward} objects encapsulate third-party objects whose logic is not known to us, we cannot do the correct jump transformation:
\begin{ffcode}
goto
  [g]
    foreign_obj > @
      QQ.io.stdout
        "We don't know the logic\n"
      g.forward TRUE
\end{ffcode}

Thus, we can guarantee transformations of \ff{forward} and \ff{backward} objects only if these objects encapsulate objects whose logic is known to us and these \ff{forward} and \ff{backward} objects are inside the \ff{goto} object.


\section{Toolkit}
\tbd{TODO}

Here we explain how we implemented an automated tool for applying all described transformations to EO code.

Then, we explain how we conducted experiments with this tool, modifying many EO programs and then running them to check whether they return the same results as original ones.



\section{Discussion}
\tbd{TODO}

Our software will simplify programs in EO language and make them more readable without using GOTO objects.

\subsection{Necessity and sufficiency}
\debate[Mikhail]{ Is it Necessary? We already have section Restrictions}

In the above transformations, only three objects are affected - \ff{if}, \ff{while} and mutable object \ff{memory}.
We only consider these objects, since all other objects that could implement the behavior of such constructs as \emph{DO-WHILE}, \emph{FOR}, \emph{REPEAT-UNTIL}, \emph{IF-THEN-ELSE} and others can be implemented using this objects.

\section{Conclusion}
\tbd{TODO}

As a result of our research, we suggested 4 transformations that automatically converts an input program to a semantically equivalent analog, but without using the \emph{atom} object \ff{goto}.
We also proved that the program at the output will contain the same logic as the program at the input.


\printbibliography %Prints bibliography
\end{document}
\endinput

\documentclass[two column]{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xcolor}

\graphicspath{ {./images/} }

% Keywords command
\providecommand{\keywords}[1]
{
  \small
  \textbf{\textit{Keywords:}} #1
}

\definecolor{codegray}{rgb}{0.5,0.5,0.5}

\lstdefinestyle{mystyle}{
  %%backgroundcolor=\color{backcolour}, commentstyle=\color{codegreen},
  %%keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  %%stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,
  frame=leftline,
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}

\title{\textbf{Elimination Of Jump Statements}}
\author{\textbf{author}}
\date{May 2022}

\lstset{style=mystyle}
\begin{document}

\maketitle






%%\begin{abstract}
%%In this article we raise the problem of the so-called Jump Statements. Getting rid of the use of operators such as goto, return, continue, break, and throw in code is the task of most modern programming languages, as the program becomes unreadable, poorly optimized and the probability of fixing errors in such a program is extremely high. 
%%We are trying to answer the following research question: “Is it possible to completely get rid of the GOTO operator in the code?”
%%\end{abstract}


\keywords{Object-Oriented Programming, software engineering, algorithms, computer science}


\section{Introduction}
The problem is known both computer science and software engineering communities for a few decades already, while it was firstly formulated by Dijkstra in 1968: he affirmed that the use of GOTO has disastrous effect and proposed to remove it from all programming languages,
Even though a few years later Knuth showed a manner for structuring programs with the GOTO statement and argued that it could be a powerful tool if it is well used, researchers got interested in finding a way for restructuring programs and eliminating GOTO statements.

Williams created a tool for restructuring Pascal code; Jonsson was one of the first who made a summary of so called GOTO-patches, which are design techniques for eliminating GOTO statements;
Erosa suggested an algorithm fir automatic elimination of GOTO statements in C;
Zegour explained how GOTO elimination may work in any language, as long as it has jump statements and control structures; Morris suggested to use regular expressions for replacing GOTO with IF-THEN-ELSE constructs;
Ramshow proposed an algorithm for Pascal programs; Ganapathi introduced optimisation method for SHIM IR; Ceccato suggested how to eliminate GOTO during migration of legacy code to Java,

To our knowledge, there is still no software tool available, which would implement any of the suggested methods and enable automatic elimination of jump statements in programs.
However, the main reason for finding a solution to this problem for us is the development of EOLANG, an experimental $\varphi$-calculus-based object-oriented programming language, which is used as an Intermediate Representation (IR) in Polystat, a new polyglot static analyzer.
The method of program analysis used in Polystat is functional: we find bugs by 1) transforming source code to formulas of $\varphi$-calculus, 2) mapping them to $\lambda$-terms, and 3) reasoning on terms using their inverses.

Such an analysis works well with statements which are easy to map to functions, for example if and switch. Jump statements, on the other hand, can't be easily mapped to functions, The presence of jump statements in the source code makes it impossible to use the functional method of analysis just explained.

The result of our research is an algorithm that allows converting a program in EO (Elementary Objects) language containing GOTO objects into a semantically similar one, but without using them.
We propose an algorithm that replaces code fragments using the GOTO object with similar fragments, but without using it. We claim that two algorithms are semantically equivalent if with the same set of input arguments they return the same results.

\section{Methods}
In EOLANG, all jump statements are implemented as a single goto-object. The goto-object represents two types of jumps: forward jump and backward jump.
Operators such as break, return and goto forward are implemented via forward jump; continue and goto backward are implemented via backward jump.

We need to find a solution for both, how to replace them in different situations. For each of them, a semantically identical replacement is required so that the algorithm returns the same output with the same input parameters. 

\subsection{forward jump}
Goto forward is implemented in EOLANG as:
\begin{lstlisting}
+import org.eolang.gray.goto
+import org.eolang.io.stdout

goto
 [g]
  seq
   g.forward TRUE
   stdout "Will never be printed"
\end{lstlisting}

In a program forward jump can be used within the body of if-statement. Structure of an algorithm can be represented by a scheme on Figure 1. Inside if-statement are located some statements (stmt1), after that goto-forward, some other statements (stmt2) and the label of goto, where the program will continue to work if the condition in if-statement was equal to TRUE.

\begin{figure}
    \centering
    \includegraphics{forward1}
    \caption{\textit{forward jump} scheme}
    \label{fig:my_label}
\end{figure}


Let's look at the following code:
\begin{lstlisting}
[x] > f
 memory > r
 seq > @
  r.write 0
  goto
   [g]
    seq > @
     if.
      x.eq 0
      g.forward
      TRUE
     r.write (42.div x)
  r
\end{lstlisting}

In this example we can see that the use of "forward jump" is unnecessary because it is called when condition within if-statement is TRUE. By inverting the condition, you can write the code block between the goto call and its label into a separate if-statement. This approach is illustrated in Figure 2.

\begin{figure}
    \centering
    \includegraphics{forward2}
    \caption{\textit{forward jump} elimination}
    \label{fig:my_label}
\end{figure}

Modified code:
\begin{lstlisting}
[x] > f
 memory > r
 seq > @
  r.write 0
  if.
   not. (eq. (x 0))
   r.write (42.div x)
   TRUE
  r
\end{lstlisting}

If the program encountered unconditional forward jump, we need to transform it as goto with an additional condition: if (true) goto forward. Then the replacement occurs just as if the condition exists.

\subsubsection{return}
As mentioned above, return statement is also implemented via goto forward object. Consider the following code:
\begin{lstlisting}
[a b] > max
 goto > @
  [g]
   seq > @
    if.
     a.greater b
     g.forward a
     TRUE
    b
\end{lstlisting}
When using goto as return statement, an additional attribute is added to the goto-object, similar to the return value of a procedure.
In this case, it can easily be transformed into an if-statement as shown in the paragraph above:
\begin{lstlisting}
[a b] > max
 if.
  not. (a.greater b)
  b
  TRUE
 a
\end{lstlisting}

\subsubsection{break}
Break is a control-flow statement which could also be implemented using goto forward. Since the break statement can only be found inside the generator (in EOlang Generator is a routine that can be used to control iteration behaviour of a loop) Its replacement is slightly different from the one presented in the paragraph above.
In this case, we need to invert the if-condition and add it to the condition of the loop with the logical operator AND.
After that, we easily get rid of the if-condition itself.

Let's look at the example:
\begin{lstlisting}
[]
 memory > i
 goto > @
  [g]
   seq > @
    while.
     i.less 10
     seq
      i.write (i.add 1)
      if.
       eq. (i.mod 5 0)
       g.forward
       TRUE
\end{lstlisting}

We invert \textit{condition} and add it to \textbf{while}-condition:
\begin{lstlisting}
[]
 memory > i
 seq > @
  while.
   and.
    i.less 10
    not. (eq. (i.mod 5 0))
   seq
    i.write (i.add 1)
\end{lstlisting}

Thus, at each iteration of the \textit{while} loop, the added condition will be checked, and as soon as it becomes \textit{FALSE}, the loop will be terminated because of the \textit{AND} statement.

\subsection{backward jump}
\textit{Backward jump} is usually used similarly to a while loop and can be easily replaced by it (considering programs that are compiled and executed). Substitution will look like \textbf{do-while} construction.

\begin{figure}[h]
    \centering
    \includegraphics{backward1}
    \caption{\textit{backward jump} scheme}
    \label{fig:my_label}
\end{figure}

Consider the following code:
\begin{lstlisting}
[] > f
 memory > i
 seq > @
  i.write 1
  goto
   [g]
    seq > @
     i.write (i.add 1)
     if.
      i.less 10
      g.backward
      TRUE
 stdout "Finished!"
\end{lstlisting}

\textbf{Goto backward} will work as long as the condition in if-statement is TRUE. In this case we could easily replace construction using \textbf{goto} with the \textit{while} loop:

\begin{figure}[h]
    \centering
    \includegraphics{backward2}
    \caption{\textit{backward jump} elimination}
    \label{fig:my_label}
\end{figure}

\begin{lstlisting}
[] > f
 memory > i
 seq > @
  i.write 1
  i.write (i.add 1)
  while.
   i.less 10
   seq
    i.write (i.add 1)
 stdout "Finished!"
\end{lstlisting}

The first iteration will always work, and all subsequent ones only as long as the condition in the loop is \textit{TRUE}.

\subsubsection{continue}
\textit{Continue} is also a control-flow statement, which occurs in loops and is implemented through the EO object \textbf{GOTO}. In order to replace it, we need to invert the \textit{if}-condition in the loop and all the statements that occur after \textbf{goto} are put in the \textit{if} body with the inverted condition.

Example of using \textit{continue} via \textbf{goto backward}:
\begin{lstlisting}
[]
 memory > i
 goto > @
  [g]
   seq > @
    while.
     i.less 10
     seq
      i.write (i.add 1)
      if.
       eq. (i.mod 5 0)
       g.backward
       TRUE
      stdout "Not divisible by 5!\n"
\end{lstlisting}

Since the \textbf{while} loop is an attribute of the \textbf{goto} object, \textit{if-condition} is executed a "jump up" that emulates the \textit{continue} statement. To get rid of this "jump" we should replace the GOTO object with the method described above:
\begin{lstlisting}
[]
 memory > i
 seq > @
 while.
  i.less 10
  seq
   i.write (i.add 1)
   if.
    not. (eq. (i.mod 5 0))
    stdout "Not divisible by 5!\n"
    TRUE
\end{lstlisting}

\subsection{Complex cases}
??? when forward and then backward jump
???
goto obj inside another goto obj????
and mb add throw ???


\subsection{Final algorithm}
Knowing how to replace a \textit{goto-forward} statement and a \textit{goto-backward} statement, we can present a final algorithm to get rid of all the GOTO objects in the EOLANG code. First, we have to determine which kind of jump we need to replace: \textit{forward jump} or \textit{backward jump}. If several GOTO objects are located inside each other, then we should first replace the internal object, then the one that is located outside, and so on. If the \textit{goto forward} object is in front of us, we should check if it has a \textbf{while}-loop attribute to change its condition when replacing this piece of code. Also, if a \textit{forward jump} appears in the code, we should consider whether this object has an additional attribute as the return value - then we should return this value in the replaced piece of code. In another case, if we have \textit{goto backward}, we should also check for a loop to add an \textit{if-statement} inside it, not create a new \textbf{while} loop.

All \textbf{goto}-objects in a program we will store in the form of a tree to make it more convenient to make replacements going from sons to parents - from more nested objects to external objects.

The pseudocode of the algorithm may look like this:

\begin{lstlisting}
//find all goto-objects and store them as a tree
goto_obj[] = ...
//walk through objects in tree walk order
for_each curr_obj in goto_obj:
  //if unconditional goto, add condition
  if "if." not in curr_obj:
    add condition "if (true)" as an attribute of obj curr_obj
    
  if curr_obj.equal goto.forward:
    // inverting condition
    curr_cond = !curr_cond
    if "while." in curr_obj:
      add curr_cond to while condition with logical operator AND
    else:
      add if-condition with curr_cond
      add stmts that goes after g.forward inside if-body
      add stmts that goes before g.forward
  else:
    if "while." in curr_obj:
      curr_cond = !curr_cond
      add if-condition with curr_cond
      add stmts that goes after g.backward inside if-body
    else:
      add stmts before "if."
      add while-loop with curr_cond condition
      add stmts which occur when "if." stmt is TRUE
      add stmts before and inside "if."
      
  eliminate curr_obj
\end{lstlisting}




\end{document}
\endinput
